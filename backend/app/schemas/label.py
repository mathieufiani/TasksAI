from datetime import datetime
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field, ConfigDict, field_validator
from app.models.task import LabelCategory, LabelingStatus


class LabelBase(BaseModel):
    """Base schema for Label"""
    label_name: str = Field(..., min_length=1, max_length=100, description="Label name")
    label_category: LabelCategory = Field(..., description="Label category")
    confidence_score: float = Field(..., ge=0.0, le=1.0, description="Confidence score between 0 and 1")
    is_primary: bool = Field(default=False, description="Whether this is a primary label to display")
    reasoning: Optional[str] = Field(None, description="Why this label was assigned")
    label_metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")


class LabelCreate(LabelBase):
    """Schema for creating a label"""
    pass


class LabelUpdate(BaseModel):
    """Schema for updating a label"""
    label_name: Optional[str] = Field(None, min_length=1, max_length=100, description="Label name")
    label_category: Optional[LabelCategory] = Field(None, description="Label category")
    confidence_score: Optional[float] = Field(None, ge=0.0, le=1.0, description="Confidence score")
    is_primary: Optional[bool] = Field(None, description="Whether this is a primary label")
    is_user_edited: Optional[bool] = Field(None, description="Whether user edited this label")


class LabelResponse(LabelBase):
    """Schema for label responses"""
    id: int
    task_id: int
    is_user_edited: bool
    original_label: Optional[str] = None
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


# Pydantic AI Agent Schemas for LLM interaction
class GeneratedLabel(BaseModel):
    """Single label generated by LLM"""
    label_name: str = Field(..., description="The label name (e.g., 'home', 'high-energy', 'morning')")
    category: LabelCategory = Field(..., description="The category this label belongs to")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Confidence score for this label (0-1)")
    reasoning: str = Field(..., description="Brief explanation why this label applies")

    @field_validator('label_name')
    @classmethod
    def normalize_label_name(cls, v: str) -> str:
        """Normalize label name to lowercase and replace spaces with hyphens"""
        return v.lower().strip().replace(' ', '-')


class UserContext(BaseModel):
    """User context information for labeling (will be expanded in future)"""
    user_id: Optional[str] = Field(None, description="User ID if available")
    timezone: Optional[str] = Field(None, description="User's timezone")
    location: Optional[str] = Field(None, description="User's current location")
    preferences: Optional[Dict[str, Any]] = Field(None, description="User preferences")


class TaskLabelingInput(BaseModel):
    """Input for the labeling agent"""
    task_id: int = Field(..., description="Task ID")
    title: str = Field(..., description="Task title")
    description: Optional[str] = Field(None, description="Task description")
    priority: str = Field(..., description="Task priority")
    due_date: Optional[datetime] = Field(None, description="Task due date")
    user_context: Optional[UserContext] = Field(default_factory=UserContext, description="User context")


class TaskLabelingOutput(BaseModel):
    """Output from the labeling agent"""
    task_id: int
    labels: List[GeneratedLabel] = Field(..., min_length=6, description="Generated labels (minimum 6)")
    summary: str = Field(..., description="Brief summary of the labeling analysis")
    external_factors_considered: List[str] = Field(
        default_factory=list,
        description="List of external factors considered (time of day, weather, etc.)"
    )

    @field_validator('labels')
    @classmethod
    def check_minimum_labels(cls, v: List[GeneratedLabel]) -> List[GeneratedLabel]:
        """Ensure at least 6 labels are provided"""
        if len(v) < 6:
            raise ValueError(f"At least 6 labels are required, got {len(v)}")
        return v


class LabelingStatusResponse(BaseModel):
    """Response for labeling status"""
    task_id: int
    labeling_status: LabelingStatus
    labeling_attempted_at: Optional[datetime] = None
    labeling_completed_at: Optional[datetime] = None
    labeling_error: Optional[str] = None
    labels_count: int = 0
    primary_labels: List[LabelResponse] = []

    model_config = ConfigDict(from_attributes=True)


class LabelFilterParams(BaseModel):
    """Parameters for filtering tasks by labels"""
    label_names: Optional[List[str]] = Field(None, description="Filter by specific label names")
    label_categories: Optional[List[LabelCategory]] = Field(None, description="Filter by label categories")
    min_confidence: Optional[float] = Field(None, ge=0.0, le=1.0, description="Minimum confidence score")
    primary_only: Optional[bool] = Field(None, description="Only return tasks with primary labels")
